# -*- coding: utf-8 -*-

from os.path import join, split
from .... import __version__

# some constant definitions
WHITESPACE = " "
INDENT = 2 * WHITESPACE
COMMENT = "! "
NEWLINE = "\n"
END = "End"

# file class
class FileClass(str):
    pass


# temp shortcut
names = [
    "Magnet_0_Body",
    "Lamination_0_Body",
    "Magnet_1_Body",
    "Magnet_0_Right_Slave",
    "Magnet_0_Bottom_Slave",
    "Magnet_0_Left_Slave",
    "Magnet_0_Top_Slave",
    "Magnet_1_Left_Slave",
    "Magnet_1_Bottom_Slave",
    "Magnet_1_Right_Slave",
    "Magnet_0_Right_Master",
    "Magnet_0_Bottom_Master",
    "Magnet_0_Left_Master",
    "Magnet_0_Top_Master",
    "Magnet_1_Left_Master",
    "Magnet_1_Bottom_Master",
    "Magnet_1_Right_Master",
    "Magnet_1_Top_Master",
    "Magnet_1_Top_Slave",
    "MASTER_ROTOR_BOUNDARY",
    "SLAVE_ROTOR_BOUNDARY",
]


def gen_case(self, output):
    """Setup the Elmer Case file (.sif file)"""

    # get the save path
    save_dir = self.get_path_save_fea(output)

    sif_file = join(save_dir, "case.sif")

    # save solver start info
    start_file = join(save_dir, "ELMERSOLVER_STARTINFO")

    with open(start_file, "wt") as fout:
        fout.write(split(sif_file)[1])

    # prepare sections
    bodies = _get_body_sections(names)
    simulation = _get_simulation_section()
    constants = _get_constants_section()
    equations = _get_equations_section()

    # save the sif file
    with open(sif_file, "wt") as f:
        f.write(COMMENT + f"-" * 80 + NEWLINE)
        f.write(COMMENT + f"File Generated by pyleecan v{__version__}" + NEWLINE)
        f.write(COMMENT + f"-" * 80 + NEWLINE)

        _write_header(f)
        _write_sections(f, simulation, "Simulation")
        _write_sections(f, bodies, "Body")
        _write_sections(f, constants, "Constants")
        _write_sections(f, equations, "Equation")


def _write_header(f):
    mesh_file = "Model"

    f.write(NEWLINE)
    f.write(f"Header")
    f.write(NEWLINE + INDENT)
    f.write(f"CHECK KEYWORDS Warn")
    f.write(NEWLINE + INDENT)
    f.write(f'Mesh DB "." "{mesh_file}"')
    f.write(NEWLINE + INDENT)
    f.write(f'Include Path ""')
    f.write(NEWLINE + INDENT)
    f.write(f'Results Directory ""')
    f.write(NEWLINE + END + NEWLINE)


def _get_body_sections(names):
    bodies = []
    for name in names:
        if "Body" in name:
            body = {}
            body["Name"] = name
            body["Equation"] = 1
            if "Magnet" in name:
                body["Material"] = 2
            elif "Lamination" in name:
                body["Material"] = 2
            body["Body Force"] = 1

            bodies.append(body)

    return bodies


def _get_simulation_section():
    sim = {}
    sim["Max Output Level"] = 5
    sim["Coordinate System"] = "Cartesian 2D"
    sim["Coordinate Mapping"] = [1, 2, 3]
    sim["Simulation Type"] = "Steady State"
    sim["Steady State Max Iterations"] = 1
    sim["Initialize Dirichlet Conditions"] = False
    sim["Output File"] = FileClass("case_2.result")
    sim["Use Mesh Names"] = True

    return sim


def _get_constants_section():
    const = {}
    const["Gravity"] = [0.0, -1.0, 0.0, 9.82]

    return const


def _get_equations_section():
    eqs = {}
    eqs["Name"] = "Equations"
    eqs["Active Solvers"] = [1, 2, 3, 4, 5]

    return [eqs]


def _write_sections(f, sections, section_name):
    # if section is a list write numbered sections
    is_nbr_sect = True
    if not isinstance(sections, list):
        is_nbr_sect = False
        sections = [sections]

    for idx, sect in enumerate(sections):
        # write section header
        nbr = str(idx + 1) if is_nbr_sect else ""
        f.write(NEWLINE)
        f.write(section_name + " " + nbr)

        # write section entries
        for key, value in sect.items():
            n = ""
            if isinstance(value, list) and len(value) > 1:
                n = "(" + str(len(value)) + ")"
            f.write(NEWLINE + INDENT)
            f.write(key + n + " = " + _convert(value))

        # end section
        f.write(NEWLINE + END + NEWLINE)


def _convert(value, get_type=True):
    if isinstance(value, FileClass):  # check before str due to inheretance
        return "File " * get_type + f'"{value}"'

    if isinstance(value, str):
        return "String " * get_type + f'"{value}"'

    if isinstance(value, float):
        return "Real " * get_type + f"{value}"

    if isinstance(value, bool):
        return "Logical " * get_type + f"{value}"

    if isinstance(value, int):
        return "Integer " * get_type + f"{value}"

    if isinstance(value, list):
        val_str = ""
        for idx, val in enumerate(value):
            get_type = True if idx == 0 else False
            val_str += _convert(val, get_type=get_type) + " "
        return val_str


"""
_TYPE_REAL = "Real"
_TYPE_INTEGER = "Integer"
_TYPE_LOGICAL = "Logical"
_TYPE_STRING = "String"
_TYPE_FILE = "File"

"""
